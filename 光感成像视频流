
from flask import Flask, Response, request
from picamera2 import Picamera2
import cv2
import time
import threading
import numpy as np
import os
import signal
import sys
import logging
import socket
import subprocess

# 环境感知功能相关全局变量
ENABLE_PERCEPTION = True  # 是否启用环境感知功能
PERCEPTION_MODE = "thermal"  # 改为热成像模式
PERCEPTION_RESOLUTION = (320, 240)  # 感知处理分辨率
THERMAL_COLORMAP = cv2.COLORMAP_JET  # 使用JET颜色映射，更接近传统热成像
THERMAL_SETTINGS = {
    "min_temp": 0,     # 最低"温度"值
    "max_temp": 255,   # 最高"温度"值
    "sensitivity": 1.2,  # 热敏感度
    "blur_size": 11,    # 模糊程度，使热成像更平滑
    "alpha": 0.95,      # 热成像图的混合权重
    "show_hotspots": False, # 不显示热点标记
    "enhance_contrast": True # 增强对比度
}
perception_data = {
    "thermal_map": None,  # 热成像图
    "hot_spots": [],     # 热点区域 [(x, y, temp), ...]
    "last_update": 0,    # 上次更新时间
    "last_results": None # 缓存的上一次结果
}
perception_lock = threading.Lock()  # 用于线程安全的访问感知数据

# 使用当前用户的主目录
home_dir = os.path.expanduser("~")
log_file = os.path.join(home_dir, "camera_server.log")

logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    handlers=[
        logging.StreamHandler(),
        logging.FileHandler(log_file)
    ]
)
logger = logging.getLogger('camera_server')

app = Flask(__name__)
picam2 = None
camera_lock = threading.Lock()
running = True
last_client_time = time.time()
active_clients = 0
max_clients = 5
clients_lock = threading.Lock()
health_check_interval = 30

# 添加帧超时检测变量
last_frame_time = 0
frame_timeout = 5  # 5秒没有新帧就重启摄像头

# 监控摄像头性能的变量
frame_times = []  # 用于FPS计算的帧时间列表
fps_stats = {"current": 0, "min": 0, "max": 0, "avg": 0}
stats_lock = threading.Lock()
latest_frame = None  # 存储最新的帧
frame_lock = threading.Lock()  # 用于保护latest_frame

# 用于控制图像处理复杂度的标志
reduce_processing = False  # 默认使用完整处理
frame_counter = 0

# 添加处理帧计数器
frame_stats = {"frames": 0, "dropped_frames": 0}

# 添加预处理的查找表，以加速颜色调整
b_lut = np.clip(np.arange(0, 256) * 0.75, 0, 255).astype(np.uint8)  # 降低蓝色通道
g_lut = np.arange(0, 256).astype(np.uint8)  # 保持绿色通道不变
r_lut = np.clip(np.arange(0, 256) * 1.15, 0, 255).astype(np.uint8)  # 增强红色通道

# 创建亮度对比度查找表
alpha_beta_lut = np.clip(np.arange(0, 256) * 1.1 + 15, 0, 255).astype(np.uint8)

# 将已编码的帧缓存
encoded_frames_cache = []
encoded_frames_cache_lock = threading.Lock()
frame_cache_size = 3
frame_cache_index = 0

# 添加时间戳缓存变量
last_timestamp = ""
last_timestamp_update = 0
timestamp_update_interval = 1.0  # 时间戳每秒更新一次，但每帧都显示

def signal_handler(sig, frame):
    global running
    logger.info("正在关闭摄像头服务...")
    running = False
    if picam2 is not None:
        try:
            picam2.stop()
        except Exception as e:
            logger.error(f"关闭摄像头时出错: {e}")
    sys.exit(0)

# 注册信号处理器
signal.signal(signal.SIGINT, signal_handler)
signal.signal(signal.SIGTERM, signal_handler)

def get_ip_address():
    try:
        # 获取本机IP地址(非回环地址)
        s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
        s.connect(("8.8.8.8", 80))
        ip = s.getsockname()[0]
        s.close()
        return ip
    except Exception as e:
        logger.error(f"获取IP地址失败: {e}")
        return "127.0.0.1"

def reset_camera():
    """重置摄像头，在出现问题时调用"""
    global picam2
    logger.warning("正在重置摄像头...")
    
    with camera_lock:
        if picam2 is not None:
            try:
                picam2.stop()
                logger.info("摄像头已停止")
            except Exception as e:
                logger.error(f"停止摄像头时出错: {e}")
            finally:
                picam2 = None
    
    # 等待一段时间再重新初始化
    time.sleep(2)
    return init_camera()

def init_camera():
    global picam2, last_frame_time
    try:
        if picam2 is not None:
            try:
                picam2.stop()
            except:
                pass
            picam2 = None
            
        attempts = 0
        logger.info("初始化摄像头...")
        
        for attempt in range(3):  # 尝试3次
            try:
                picam2 = Picamera2()
                
                # 参考优化后的摄像头参数
                config = picam2.create_video_configuration(
                    main={
                        "size": (640, 480),
                        "format": "RGB888"
                    },
                    buffer_count=4,  # 增加缓冲区数量
                    controls={
                        "FrameDurationLimits": (33333, 33333),  # 约30fps
                        "AwbEnable": True,      # 保持自动白平衡
                        "AwbMode": 1,           # 使用日光模式
                        "Brightness": 0.1,      # 轻微提高亮度
                        "Contrast": 1.0,        # 默认对比度
                        "Saturation": 1.1,      # 轻微提高饱和度
                        "Sharpness": 1.0,       # 默认锐度
                        "ExposureValue": 0.2,   # 曝光补偿
                        "ColourGains": (1.4, 1.2)  # 更温和的红绿增益
                    }
                )
                
                picam2.configure(config)
                time.sleep(0.5)
                
                picam2.start()
                logger.info(f"摄像头初始化成功 (尝试 {attempt+1}/3)")
                
                # 丢弃前几帧
                for _ in range(5):
                    picam2.capture_array()
                    time.sleep(0.03)
                
                return True
                
            except Exception as e:
                logger.error(f"摄像头初始化尝试 {attempt+1}/3 失败: {e}")
                if picam2 is not None:
                    try:
                        picam2.stop()
                    except:
                        pass
                    picam2 = None
                time.sleep(2)
        
        return False
        
    except Exception as e:
        logger.error(f"初始化摄像头过程中发生错误: {e}")
        return False

def adjust_colors_fast(frame):
    """使用查找表快速调整颜色"""
    try:
        if frame is None or frame.size == 0:
            return None
            
        # 使用OpenCV的split/LUT/merge操作，这些操作经过高度优化
        b, g, r = cv2.split(frame)
        b = cv2.LUT(b, b_lut)
        r = cv2.LUT(r, r_lut)
        
        # 使用优化的合并操作
        adjusted = cv2.merge([b, g, r])
        
        # 使用查找表进行亮度和对比度调整，避免逐像素计算
        adjusted = cv2.LUT(adjusted, alpha_beta_lut)
        
        return adjusted
    except Exception as e:
        logger.error(f"快速颜色调整出错: {e}")
        return frame

def enhance_frame(frame):
    """简单的帧增强，保持帧率"""
    # 使用CLAHE增强对比度
    lab = cv2.cvtColor(frame, cv2.COLOR_BGR2LAB)
    l, a, b = cv2.split(lab)
    clahe = cv2.createCLAHE(clipLimit=2.0, tileGridSize=(8, 8))
    cl = clahe.apply(l)
    limg = cv2.merge((cl, a, b))
    enhanced = cv2.cvtColor(limg, cv2.COLOR_LAB2BGR)
    return enhanced

def detect_thermal(frame):
    """处理热成像效果，实现更接近专业红外热成像效果"""
    # 降低分辨率以提高速度
    small_frame = cv2.resize(frame, PERCEPTION_RESOLUTION)
    
    # 将图像转换为HSV颜色空间
    hsv = cv2.cvtColor(small_frame, cv2.COLOR_BGR2HSV)
    h, s, v = cv2.split(hsv)
    
    # 使用V通道（亮度）作为温度的近似值
    temp_map = v.copy()
    
    # 应用高斯模糊使热成像更平滑
    blur_size = THERMAL_SETTINGS["blur_size"]
    temp_map = cv2.GaussianBlur(temp_map, (blur_size, blur_size), 0)
    
    # 增强对比度
    if THERMAL_SETTINGS["enhance_contrast"]:
        # 使用CLAHE（对比度受限的自适应直方图均衡化）
        clahe = cv2.createCLAHE(clipLimit=2.0, tileGridSize=(8, 8))
        temp_map = clahe.apply(temp_map)
    
    # 应用gamma校正增强高温区域
    gamma = THERMAL_SETTINGS["sensitivity"]
    temp_map = np.power(temp_map / 255.0, gamma) * 255.0
    temp_map = temp_map.astype(np.uint8)
    
    # 查找热点区域
    # 应用阈值处理找到热点区域
    _, thresh = cv2.threshold(temp_map, 180, 255, cv2.THRESH_BINARY)
    
    # 查找热点区域
    contours, _ = cv2.findContours(thresh, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)
    hot_spots = []
    
    # 只在需要显示热点时处理
    if THERMAL_SETTINGS["show_hotspots"]:
        for contour in contours:
            # 计算轮廓的面积，过滤小区域
            area = cv2.contourArea(contour)
            if area > 100:  # 增大阈值，减少热点数量
                # 计算轮廓的中心点和平均"温度"
                M = cv2.moments(contour)
                if M["m00"] != 0:
                    cx = int(M["m10"] / M["m00"])
                    cy = int(M["m01"] / M["m00"])
                    mask = np.zeros_like(temp_map)
                    cv2.drawContours(mask, [contour], -1, 255, -1)
                    mean_temp = cv2.mean(temp_map, mask=mask)[0]
                    hot_spots.append((cx, cy, mean_temp))
    
    # 创建热成像图
    # 应用颜色映射
    thermal_map = cv2.applyColorMap(temp_map, THERMAL_COLORMAP)
    
    return thermal_map, hot_spots, temp_map

def detect_obstacles(frame, floor_mask):
    """基于地面掩码检测障碍物"""
    # 创建障碍物掩码 (非地面区域)
    obstacle_mask = cv2.bitwise_not(floor_mask)
    
    # 应用形态学操作去除噪点
    kernel = np.ones((5, 5), np.uint8)
    obstacle_mask = cv2.morphologyEx(obstacle_mask, cv2.MORPH_OPEN, kernel)
    
    # 找到障碍物的轮廓
    contours, _ = cv2.findContours(obstacle_mask, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)
    
    # 初始化障碍物列表
    obstacles = []
    
    # 处理找到的轮廓
    for contour in contours:
        # 计算轮廓面积，排除小噪点
        area = cv2.contourArea(contour)
        if area > 100:  # 面积阈值，可以调整
            x, y, w, h = cv2.boundingRect(contour)
            obstacles.append((x, y, w, h))
    
    return obstacles, obstacle_mask

def create_distance_map(floor_mask, obstacles):
    """创建简单的距离图，模拟激光雷达效果"""
    # 初始化距离图 (黑色背景)
    distance_map = np.zeros_like(floor_mask)
    
    # 在地面掩码上应用距离变换
    dist_transform = cv2.distanceTransform(floor_mask, cv2.DIST_L2, 3)
    
    # 归一化距离变换结果至0-255范围
    cv2.normalize(dist_transform, dist_transform, 0, 255, cv2.NORM_MINMAX)
    distance_map = dist_transform.astype(np.uint8)
    
    # 创建伪彩色图像
    distance_map_color = cv2.applyColorMap(distance_map, cv2.COLORMAP_JET)
    
    # 标记障碍物区域为红色
    for (x, y, w, h) in obstacles:
        cv2.rectangle(distance_map_color, (x, y), (x+w, y+h), (0, 0, 255), 2)
    
    return distance_map_color

def plan_safe_path(floor_mask, obstacles):
    """基于地面掩码和障碍物规划简单的安全路径"""
    # 创建安全路径点
    height, width = floor_mask.shape
    center_x = width // 2
    
    # 从底部中心向上采样路径点
    safe_path = []
    y_step = 10
    
    for y in range(height-10, 0, -y_step):
        # 对当前y值的一行进行扫描，找到最佳x值
        best_x = center_x  # 默认为中心线
        best_distance = 0
        
        # 扫描该行，寻找离障碍物最远的点
        for x in range(width):
            if floor_mask[y, x] > 0:  # 如果是地面区域
                # 计算到所有障碍物的最小距离
                min_distance = float('inf')
                for (ox, oy, ow, oh) in obstacles:
                    # 计算到障碍物矩形的距离
                    dx = max(ox - x, 0, x - (ox + ow))
                    dy = max(oy - y, 0, y - (oy + oh))
                    distance = np.sqrt(dx*dx + dy*dy)
                    min_distance = min(min_distance, distance)
                
                # 如果这个点比之前找到的点离障碍物更远
                if min_distance > best_distance:
                    best_distance = min_distance
                    best_x = x
        
        # 添加到安全路径
        if floor_mask[y, best_x] > 0:  # 再次确认是地面区域
            safe_path.append((best_x, y))
    
    return safe_path

def visualize_perception(frame, perception_results):
    """将感知结果可视化到原始帧上"""
    # 获取热成像结果
    thermal_map = perception_results.get("thermal_map")
    hot_spots = perception_results.get("hot_spots", [])
    
    # 创建一个原始帧的副本
    result = frame.copy()
    
    # 调整感知结果大小以匹配原始帧
    h, w = frame.shape[:2]
    
    if thermal_map is not None:
        # 调整热成像图大小
        thermal_map_resized = cv2.resize(thermal_map, (w, h))
        
        # 将热成像图与原图混合 - 使用较高的alpha值让热成像更明显
        alpha = THERMAL_SETTINGS["alpha"]  # 使用设置中的混合权重
        result = cv2.addWeighted(result, 1-alpha, thermal_map_resized, alpha, 0)
        
        # 在右下角小窗口中显示纯净版热成像 (可选)
        thermal_small = cv2.resize(thermal_map, (w//4, h//4))
        x_offset = w - thermal_small.shape[1] - 10  # 添加一些边距
        y_offset = h - thermal_small.shape[0] - 10
        
        # 为小窗口添加边框
        cv2.rectangle(result, 
                    (x_offset-2, y_offset-2), 
                    (x_offset+thermal_small.shape[1]+2, y_offset+thermal_small.shape[0]+2), 
                    (255, 255, 255), 
                    1)
        
        # 插入小窗口
        result[y_offset:y_offset+thermal_small.shape[0], 
               x_offset:x_offset+thermal_small.shape[1]] = thermal_small
    
    # 仅当设置允许时显示热点
    if THERMAL_SETTINGS["show_hotspots"]:
        # 标记热点
        for (x, y, temp) in hot_spots:
            # 计算颜色（基于温度）
            temp_normalized = min(1.0, max(0.0, temp / 255.0))
            color = (0, int(255 * (1-temp_normalized)), int(255 * temp_normalized))
            
            # 在主图像上标记热点
            scale_x = w / PERCEPTION_RESOLUTION[0]
            scale_y = h / PERCEPTION_RESOLUTION[1]
            pos = (int(x * scale_x), int(y * scale_y))
            cv2.circle(result, pos, 5, color, 2)
    
    # 添加模式指示器
    cv2.putText(result, "Mode: Thermal", (10, 70), 
                cv2.FONT_HERSHEY_SIMPLEX, 0.5, (255, 255, 255), 1)
    
    return result

def process_perception(frame):
    """处理环境感知，更新全局感知数据"""
    global perception_data
    
    try:
        # 处理热成像
        thermal_map, hot_spots, temp_map = detect_thermal(frame)
        
        # 更新全局感知数据
        with perception_lock:
            perception_data["thermal_map"] = thermal_map
            perception_data["hot_spots"] = hot_spots
            perception_data["last_update"] = time.time()
        
        # 返回所有感知结果，用于可视化
        return {
            "thermal_map": thermal_map,
            "hot_spots": hot_spots,
            "temp_map": temp_map
        }
        
    except Exception as e:
        logger.error(f"处理环境感知时出错: {e}")
        return None

def update_fps_stats(frame_time):
    """计算并更新FPS统计信息"""
    global fps_stats, frame_times
    with stats_lock:
        # 保留最近10帧的时间，减少计算量
        frame_times.append(frame_time)
        if len(frame_times) > 10:
            frame_times.pop(0)
            
        # 计算FPS
        if len(frame_times) > 1:
            # 使用简单的FPS计算方法
            elapsed = frame_times[-1] - frame_times[0]
            if elapsed > 0:
                fps = (len(frame_times) - 1) / elapsed
                
                fps_stats["current"] = fps
                if fps_stats["min"] == 0 or fps < fps_stats["min"]:
                    fps_stats["min"] = fps
                if fps > fps_stats["max"]:
                    fps_stats["max"] = fps
                # 使用简单平均
                fps_stats["avg"] = fps

def process_frame(frame):
    """简化的帧处理函数，解决闪烁问题"""
    try:
        if frame is None or frame.size == 0:
            return None
            
        # 检查帧的形状和格式
        if len(frame.shape) != 3:
            logger.error(f"帧格式错误: 形状 {frame.shape}")
            return None
            
        # 简单的亮度和对比度增强，保持一致性
        frame = enhance_frame(frame)
        
        # 如果启用了环境感知，处理感知功能
        if ENABLE_PERCEPTION:
            # 每5帧处理一次感知，以保持高帧率
            with stats_lock:
                current_frame_count = frame_stats["frames"]
            
            perception_results = None
            if current_frame_count % 3 == 0:  # 每3帧处理一次，提高更新频率
                # 处理环境感知
                perception_results = process_perception(frame)
                
                # 缓存最新的感知结果
                if perception_results:
                    with perception_lock:
                        perception_data["last_results"] = perception_results
            else:
                # 使用缓存的上一次结果，避免闪烁
                with perception_lock:
                    perception_results = perception_data.get("last_results")
            
            # 可视化感知结果
            if perception_results:
                frame = visualize_perception(frame, perception_results)
        
        # 添加时间戳和FPS信息
        current_time = time.strftime("%Y-%m-%d %H:%M:%S", time.localtime())
        
        # 获取当前FPS
        with stats_lock:
            current_fps = fps_stats["current"]
        fps_text = f"FPS: {current_fps:.1f}"
        
        # 添加时间戳
        text_size = cv2.getTextSize(current_time, cv2.FONT_HERSHEY_SIMPLEX, 0.5, 1)[0]
        cv2.rectangle(frame, (10, 10), (10 + text_size[0], 10 + text_size[1] + 5), (0, 0, 0), -1)
        cv2.putText(frame, current_time, (10, 25), cv2.FONT_HERSHEY_SIMPLEX, 0.5, (255, 255, 255), 1)
        
        # 添加FPS信息
        fps_text_size = cv2.getTextSize(fps_text, cv2.FONT_HERSHEY_SIMPLEX, 0.5, 1)[0]
        cv2.rectangle(frame, (10, 35), (10 + fps_text_size[0], 35 + fps_text_size[1] + 5), (0, 0, 0), -1)
        cv2.putText(frame, fps_text, (10, 50), cv2.FONT_HERSHEY_SIMPLEX, 0.5, (255, 255, 255), 1)
        
        return frame
    except Exception as e:
        logger.error(f"处理帧出错: {e}")
        return None

def is_valid_frame(frame):
    """快速帧验证，减少处理时间提高帧率"""
    if frame is None or frame.size == 0:
        return False
    
    try:
        # 仅执行基本检查，减少处理时间
        # 检查帧形状
        if len(frame.shape) != 3:
            return False
        
        # 只检查图像部分区域以加速处理
        # 从中心取样本区域
        h, w = frame.shape[:2]
        center_y, center_x = h // 2, w // 2
        sample_size = 50  # 采样区域大小
        
        sample = frame[
            max(0, center_y - sample_size):min(h, center_y + sample_size),
            max(0, center_x - sample_size):min(w, center_x + sample_size)
        ]
        
        # 快速检查样本区域
        avg_value = np.mean(sample)
        if avg_value < 5:  # 几乎全黑
            return False
            
        # 快速检查颜色分布
        std_value = np.std(sample)
        if std_value < 3:  # 几乎单色
            return False
            
        return True
    except Exception as e:
        logger.error(f"帧验证错误: {e}")
        return False

def capture_continuous():
    """优化的帧捕获函数，专注于提高帧率和稳定性"""
    global picam2, running, latest_frame, last_frame_time, frame_counter, frame_stats
    
    logger.info("开始后台帧捕获线程")
    
    # 记录性能数据
    frame_times = []
    
    while running:
        try:
            if picam2 is None:
                if not init_camera():
                    time.sleep(1)
                    continue
            
            # 开始计时
            frame_start_time = time.time()
            
            try:
                # 尽量减少锁的持有时间
                with camera_lock:
                    if picam2 is None:
                        continue
                    frame = picam2.capture_array()
                
                if frame is not None and frame.size > 0:
                    frame_counter += 1
                    
                    # 更新帧统计信息
                    with stats_lock:
                        frame_stats["frames"] += 1
                    
                    # 每一帧都做相同处理，保持一致性
                    processed_frame = process_frame(frame)
                    
                    if processed_frame is not None:
                        # 更新帧数据
                        with frame_lock:
                            latest_frame = processed_frame
                            last_frame_time = time.time()
                            update_fps_stats(time.time())
                        
                        # 编码缓存
                        encode_and_cache_frame(processed_frame)
                        
                        # 记录帧处理时间
                        frame_times.append(time.time() - frame_start_time)
                        if len(frame_times) > 30:
                            # 每30帧记录一次平均处理时间
                            avg_time = sum(frame_times) / len(frame_times)
                            logger.debug(f"平均帧处理时间: {avg_time*1000:.1f}ms，约等于 {1/avg_time:.1f}fps")
                            frame_times = []
                    
                    # 动态休眠控制帧率
                    elapsed = time.time() - frame_start_time
                    if elapsed < 0.03:  # 目标30+fps
                        # 非常短的休眠以节省CPU，同时保持高帧率
                        time.sleep(0.001)
                
            except Exception as e:
                logger.error(f"捕获帧异常: {e}")
                time.sleep(0.1)
                
        except Exception as e:
            logger.error(f"帧捕获线程错误: {e}")
            time.sleep(0.1)

def encode_and_cache_frame(frame):
    """编码并缓存当前帧为JPEG格式"""
    global encoded_frames_cache
    
    if frame is None:
        logger.warning("无法编码空帧")
        return
    
    try:
        # 确保清晰的图像质量，但避免过大
        _, buffer = cv2.imencode('.jpg', frame, [cv2.IMWRITE_JPEG_QUALITY, 85])
        
        with encoded_frames_cache_lock:
            # 单帧缓存，确保最新
            encoded_frames_cache = [{"time": time.time(), "data": buffer.tobytes()}]
    except Exception as e:
        logger.error(f"编码帧出错: {e}")

def get_cached_frame():
    """获取最新的缓存帧"""
    global encoded_frames_cache
    
    with encoded_frames_cache_lock:
        if not encoded_frames_cache:
            return b''
        return encoded_frames_cache[0]["data"]

def generate_frames():
    """优化的帧生成器，提高帧率和减少闪烁"""
    global running, active_clients
    client_id = time.time()
    target_interval = 1.0 / 30.0  # 目标30fps
    
    with clients_lock:
        active_clients += 1
        logger.info(f"客户端 {client_id:.2f} 连接，当前活跃客户端: {active_clients}")
    
    try:
        last_frame_time = time.time()
        while running:
            try:
                # 保持固定间隔发送帧
                now = time.time()
                time_to_wait = target_interval - (now - last_frame_time)
                
                if time_to_wait > 0:
                    # 使用极短的休眠
                    time.sleep(0.001)
                    continue
                
                # 重置时间
                last_frame_time = now
                
                # 获取缓存帧
                buffer = get_cached_frame()
                if buffer is None:
                    continue
                
                # 发送帧数据
                yield (b'--frame\r\n'
                       b'Content-Type: image/jpeg\r\n\r\n' + buffer + b'\r\n')
                
            except Exception as e:
                logger.error(f"生成帧异常: {e}")
                time.sleep(0.03)
                
    except Exception as e:
        logger.error(f"生成帧异常: {e}")
    finally:
        with clients_lock:
            active_clients -= 1
            logger.info(f"客户端 {client_id:.2f} 断开，当前活跃客户端: {active_clients}")

@app.route('/')
def index():
    # 获取当前IP和服务URL
    ip = get_ip_address()
    service_url = f"http://{ip}:8000/video_feed"
    
    return f"""
    <!DOCTYPE html>
    <html>
    <head>
        <title>摄像头流</title>
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <style>
            body {{
                font-family: Arial, sans-serif;
                margin: 0;
                padding: 20px;
                text-align: center;
                background-color: #f0f0f0;
            }}
            h1 {{
                color: #333;
            }}
            .container {{
                max-width: 800px;
                margin: 0 auto;
                background: white;
                padding: 20px;
                border-radius: 8px;
                box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            }}
            img {{
                max-width: 100%;
                border-radius: 4px;
            }}
            .info {{
                margin-top: 20px;
                padding: 10px;
                background: #e9f7fe;
                border-radius: 4px;
                text-align: left;
            }}
            .reload {{
                display: inline-block;
                margin-top: 10px;
                padding: 8px 15px;
                background-color: #4CAF50;
                color: white;
                border: none;
                border-radius: 4px;
                cursor: pointer;
            }}
            .reload:hover {{
                background-color: #45a049;
            }}
        </style>
        <script>
            // 自动重连功能
            function setupAutoReconnect() {{
                const img = document.getElementById('stream');
                let reconnectTimer = null;
                let errorCounter = 0;
                
                img.onload = function() {{
                    console.log('视频流已加载');
                    errorCounter = 0;
                }};
                
                img.onerror = function() {{
                    errorCounter++;
                    console.log(`视频流错误 (${{errorCounter}}次)`);
                    
                    if (errorCounter <= 5) {{
                        if (reconnectTimer) clearTimeout(reconnectTimer);
                        
                        reconnectTimer = setTimeout(function() {{
                            console.log('尝试重新加载视频流...');
                            img.src = '/video_feed?t=' + new Date().getTime();
                        }}, 2000);
                    }} else {{
                        console.log('多次重连失败，请手动刷新页面');
                        document.getElementById('reconnect-msg').style.display = 'block';
                    }}
                }};
            }}
            
            window.onload = function() {{
                setupAutoReconnect();
                
                // 手动重新加载
                document.getElementById('reload-btn').onclick = function() {{
                    location.reload();
                }};
            }};
        </script>
    </head>
    <body>
        <div class="container">
            <h1>树莓派摄像头流</h1>
            <img id="stream" src="/video_feed" alt="摄像头流">
            <div id="reconnect-msg" style="display: none; color: red; margin-top: 10px;">
                视频流连接出现问题。
                <button id="reload-btn" class="reload">刷新页面</button>
            </div>
            <div class="info">
                <p><strong>服务器IP:</strong> {ip}</p>
                <p><strong>视频流URL:</strong> {service_url}</p>
                <p><strong>活跃连接:</strong> {active_clients}/{max_clients}</p>
                <p>树莓派摄像头服务正在运行</p>
            </div>
        </div>
    </body>
    </html>
    """

@app.route('/video_feed')
def video_feed():
    # 限制最大客户端数量
    with clients_lock:
        if active_clients >= max_clients:
            return "达到最大连接数，请稍后再试", 503
    
    # 返回视频流
    return Response(generate_frames(),
                    mimetype='multipart/x-mixed-replace; boundary=frame')

@app.route('/status')
def status():
    """返回服务器状态信息"""
    with stats_lock:
        status_data = {
            "active_clients": active_clients,
            "max_clients": max_clients,
            "fps": fps_stats,
            "uptime": time.time() - service_start_time,
            "camera_status": "running" if picam2 is not None else "stopped",
            "server_ip": get_ip_address(),
            "reduce_processing": reduce_processing
        }
    return status_data

@app.route('/reset_camera', methods=['POST'])
def reset_camera_endpoint():
    """手动重置摄像头的API端点"""
    success = reset_camera()
    if success:
        return {"status": "success", "message": "摄像头已重置"}
    else:
        return {"status": "error", "message": "摄像头重置失败"}, 500

@app.route('/restart_service', methods=['POST'])
def restart_service_endpoint():
    """重启整个视频流服务的API端点"""
    try:
        logger.info("收到重启服务请求，准备重启服务...")
        # 这里我们创建一个独立进程来重启服务，这样当前进程可以正常返回响应
        subprocess.Popen(['sudo', 'systemctl', 'restart', 'camera-service'], 
                          stdout=subprocess.PIPE, 
                          stderr=subprocess.PIPE)
        return {"status": "success", "message": "重启服务请求已发送，服务即将重启"}
    except Exception as e:
        logger.error(f"重启服务失败: {e}")
        return {"status": "error", "message": f"重启服务失败: {e}"}, 500

@app.route('/debug')
def debug_info():
    """显示调试信息页面"""
    # 收集系统信息
    try:
        cpu_info = subprocess.check_output("cat /proc/cpuinfo | grep 'model name' | head -1", shell=True).decode().strip()
        memory_info = subprocess.check_output("free -h", shell=True).decode()
        disk_info = subprocess.check_output("df -h /", shell=True).decode()
        uptime = subprocess.check_output("uptime", shell=True).decode().strip()
        camera_info = "PiCamera2 已初始化" if picam2 is not None else "PiCamera2 未初始化"
        
        # 获取摄像头状态
        camera_status = {}
        if picam2 is not None:
            camera_status = {
                "resolution": str(picam2.camera_config["main"]["size"]),
                "format": picam2.camera_config["main"]["format"],
                "fps": picam2.camera_config.get("frame_rate", "未知")
            }
        
        # 获取性能统计信息
        with stats_lock:
            stats_copy = frame_stats.copy()
            fps_copy = fps_stats.copy()
            
        return f"""
        <!DOCTYPE html>
        <html>
        <head>
            <title>摄像头服务器调试信息</title>
            <meta charset="utf-8">
            <meta name="viewport" content="width=device-width, initial-scale=1">
            <style>
                body {{ font-family: Arial, sans-serif; padding: 20px; }}
                .debug-section {{ margin-bottom: 20px; }}
                h2 {{ color: #333; }}
                pre {{ background-color: #f8f8f8; padding: 10px; overflow-x: auto; }}
            </style>
        </head>
        <body>
            <h1>摄像头服务器调试信息</h1>
            
            <div class="debug-section">
                <h2>系统信息</h2>
                <p><strong>CPU:</strong> {cpu_info.split(':')[1].strip() if ':' in cpu_info else cpu_info}</p>
                <p><strong>内存:</strong></p>
                <pre>{memory_info}</pre>
                <p><strong>磁盘:</strong></p>
                <pre>{disk_info}</pre>
                <p><strong>运行时间:</strong> {uptime}</p>
            </div>
            
            <div class="debug-section">
                <h2>摄像头状态</h2>
                <p>{camera_info}</p>
                {f"<p><strong>分辨率:</strong> {camera_status['resolution']}</p>" if picam2 else ""}
                {f"<p><strong>格式:</strong> {camera_status['format']}</p>" if picam2 else ""}
                {f"<p><strong>帧率:</strong> {camera_status['fps']}</p>" if picam2 else ""}
            </div>
            
            <div class="debug-section">
                <h2>性能统计</h2>
                <p><strong>总帧数:</strong> {stats_copy['frames']}</p>
                <p><strong>丢弃帧数:</strong> {stats_copy['dropped_frames']}</p>
                <p><strong>当前FPS:</strong> {fps_copy['current']:.2f}</p>
                <p><strong>平均FPS:</strong> {fps_copy['avg']:.2f}</p>
                <p><strong>最大FPS:</strong> {fps_copy['max']:.2f}</p>
                <p><strong>活跃客户端:</strong> {active_clients}</p>
            </div>
            
            <div class="debug-section">
                <h2>操作</h2>
                <button onclick="fetch('/reset_camera', {{method: 'POST'}}).then(response => alert('摄像头已重置'))">重置摄像头</button>
                <button onclick="fetch('/restart_service', {{method: 'POST'}}).then(response => alert('服务正在重启...')).catch(err => alert('重启请求已发送'))">重启服务</button>
            </div>
        </body>
        </html>
        """
    except Exception as e:
        return f"获取调试信息时出错: {e}", 500

@app.route('/perception', methods=['GET', 'POST'])
def perception_endpoint():
    """获取和控制环境感知功能"""
    global ENABLE_PERCEPTION, PERCEPTION_MODE, THERMAL_COLORMAP, THERMAL_SETTINGS
    
    # 处理POST请求 - 更改感知配置
    if request.method == 'POST':
        try:
            data = request.json or {}
            
            # 更新启用/禁用状态
            if 'enable' in data:
                ENABLE_PERCEPTION = bool(data['enable'])
            
            # 更新热成像设置
            if 'settings' in data:
                settings = data['settings']
                if 'sensitivity' in settings:
                    THERMAL_SETTINGS["sensitivity"] = float(settings['sensitivity'])
                if 'alpha' in settings:
                    THERMAL_SETTINGS["alpha"] = float(settings['alpha'])
                if 'blur_size' in settings:
                    THERMAL_SETTINGS["blur_size"] = int(settings['blur_size'])
                    # 确保blur_size是奇数
                    if THERMAL_SETTINGS["blur_size"] % 2 == 0:
                        THERMAL_SETTINGS["blur_size"] += 1
                if 'show_hotspots' in settings:
                    THERMAL_SETTINGS["show_hotspots"] = bool(settings['show_hotspots'])
                if 'enhance_contrast' in settings:
                    THERMAL_SETTINGS["enhance_contrast"] = bool(settings['enhance_contrast'])
                if 'colormap' in settings:
                    # 设置颜色映射
                    colormap_values = [
                        cv2.COLORMAP_JET,
                        cv2.COLORMAP_HOT,
                        cv2.COLORMAP_INFERNO,
                        cv2.COLORMAP_RAINBOW,
                        cv2.COLORMAP_PLASMA
                    ]
                    colormap_idx = int(settings['colormap'])
                    if 0 <= colormap_idx < len(colormap_values):
                        THERMAL_COLORMAP = colormap_values[colormap_idx]
                
                # 清空缓存的感知结果，强制重新处理
                with perception_lock:
                    perception_data["last_results"] = None
                
            return {"success": True, "enable": ENABLE_PERCEPTION, "mode": PERCEPTION_MODE, "settings": THERMAL_SETTINGS}
        except Exception as e:
            logger.error(f"更新感知设置时出错: {e}")
            return {"success": False, "error": str(e)}, 400
    
    # 处理GET请求 - 返回当前感知数据和配置
    else:
        try:
            # 获取最新的感知数据
            with perception_lock:
                perception_copy = {
                    "thermal_map": perception_data["thermal_map"],
                    "hot_spots": perception_data["hot_spots"],
                    "last_update": perception_data["last_update"]
                }
            
            # 添加当前配置
            perception_copy["config"] = {
                "enable": ENABLE_PERCEPTION,
                "mode": PERCEPTION_MODE,
                "settings": THERMAL_SETTINGS
            }
            
            return perception_copy
        except Exception as e:
            logger.error(f"获取感知数据时出错: {e}")
            return {"success": False, "error": str(e)}, 500

@app.route('/perception.html')
def perception_page():
    """环境感知控制和可视化页面"""
    ip = get_ip_address()
    video_url = f"http://{ip}:8000/video_feed"
    
    # 获取当前热成像设置，避免引用未定义变量
    sensitivity = THERMAL_SETTINGS["sensitivity"]
    alpha = THERMAL_SETTINGS["alpha"]
    blur_size = THERMAL_SETTINGS["blur_size"]
    show_hotspots = THERMAL_SETTINGS["show_hotspots"]
    enhance_contrast = THERMAL_SETTINGS["enhance_contrast"]
    
    return f"""
    <!DOCTYPE html>
    <html>
    <head>
        <title>机械狗环境感知控制</title>
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <style>
            body {{
                font-family: Arial, sans-serif;
                margin: 0;
                padding: 20px;
                background-color: #f5f5f5;
            }}
            h1, h2 {{
                color: #333;
            }}
            .container {{
                max-width: 1200px;
                margin: 0 auto;
                background-color: white;
                padding: 20px;
                border-radius: 8px;
                box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            }}
            .video-container {{
                width: 100%;
                margin-bottom: 20px;
                text-align: center;
            }}
            .video-feed {{
                max-width: 100%;
                border: 1px solid #ddd;
                border-radius: 4px;
            }}
            .controls {{
                display: flex;
                flex-wrap: wrap;
                gap: 20px;
                margin-bottom: 20px;
            }}
            .control-group {{
                flex: 1;
                min-width: 200px;
                border: 1px solid #ddd;
                padding: 15px;
                border-radius: 4px;
            }}
            button {{
                background-color: #4CAF50;
                color: white;
                border: none;
                padding: 10px 15px;
                margin: 5px 0;
                border-radius: 4px;
                cursor: pointer;
            }}
            button:hover {{
                background-color: #45a049;
            }}
            button.disabled {{
                background-color: #cccccc;
            }}
            .status {{
                margin-top: 20px;
                padding: 10px;
                background-color: #f8f8f8;
                border-radius: 4px;
            }}
            select {{
                padding: 8px;
                margin: 5px 0;
                width: 100%;
            }}
            .thermal-data {{
                height: 150px;
                overflow-y: auto;
                background-color: #f8f8f8;
                padding: 10px;
                font-family: monospace;
                font-size: 12px;
            }}
            .slider-container {{
                margin: 10px 0;
            }}
            .slider-container label {{
                display: block;
                margin-bottom: 5px;
            }}
            .slider-container input[type=range] {{
                width: 100%;
            }}
            .slider-value {{
                display: inline-block;
                margin-left: 10px;
                font-weight: bold;
            }}
        </style>
    </head>
    <body>
        <div class="container">
            <h1>机械狗环境感知控制</h1>
            
            <div class="video-container">
                <img src="{video_url}" alt="视频流" class="video-feed">
            </div>
            
            <div class="controls">
                <div class="control-group">
                    <h2>热成像控制</h2>
                    <button id="toggle-perception">启用热成像</button>
                    
                    <div class="slider-container">
                        <label for="sensitivity">热敏感度: <span id="sensitivity-value">{sensitivity}</span></label>
                        <input type="range" id="sensitivity" min="0.5" max="2.0" step="0.1" value="{sensitivity}">
                    </div>
                    
                    <div class="slider-container">
                        <label for="alpha">混合强度: <span id="alpha-value">{alpha}</span></label>
                        <input type="range" id="alpha" min="0.1" max="1.0" step="0.05" value="{alpha}">
                    </div>
                    
                    <div class="slider-container">
                        <label for="blur">平滑强度: <span id="blur-value">{blur_size}</span></label>
                        <input type="range" id="blur" min="3" max="25" step="2" value="{blur_size}">
                    </div>
                    
                    <label>
                        <input type="checkbox" id="show-hotspots" {"checked" if show_hotspots else ""}> 显示热点标记
                    </label>
                    
                    <label>
                        <input type="checkbox" id="enhance-contrast" {"checked" if enhance_contrast else ""}> 增强对比度
                    </label>
                    
                    <div class="color-map">
                        <label for="colormap">颜色映射:</label>
                        <select id="colormap">
                            <option value="0" selected>COLORMAP_JET</option>
                            <option value="1">COLORMAP_HOT</option>
                            <option value="2">COLORMAP_INFERNO</option>
                            <option value="3">COLORMAP_RAINBOW</option>
                            <option value="4">COLORMAP_PLASMA</option>
                        </select>
                    </div>
                </div>
                
                <div class="control-group">
                    <h2>自主导航</h2>
                    <button id="auto-navigation" class="disabled">启用自主导航</button>
                    <p>自主导航需要先启用环境感知功能</p>
                </div>
                
                <div class="control-group">
                    <h2>热成像数据</h2>
                    <div id="thermal-data" class="thermal-data">
                        等待数据...
                    </div>
                </div>
            </div>
            
            <div class="status" id="status">
                状态: 正在加载...
            </div>
        </div>
        
        <script>
            // 全局变量
            let perceptionEnabled = true;  // 默认启用
            let currentSettings = {{
                sensitivity: {sensitivity},
                alpha: {alpha},
                blur_size: {blur_size},
                show_hotspots: {str(show_hotspots).lower()},
                enhance_contrast: {str(enhance_contrast).lower()},
                colormap: 0  // COLORMAP_JET
            }};
            
            // 页面加载时获取当前状态
            window.onload = function() {{
                updateStatus();
                // 定时更新状态
                setInterval(updateStatus, 3000);
                
                // 设置按钮事件处理
                document.getElementById('toggle-perception').addEventListener('click', togglePerception);
                document.getElementById('auto-navigation').addEventListener('click', toggleNavigation);
                
                // 设置滑块事件
                document.getElementById('sensitivity').addEventListener('input', function() {{
                    let value = parseFloat(this.value);
                    document.getElementById('sensitivity-value').textContent = value.toFixed(1);
                    updateSettings({{'sensitivity': value}});
                }});
                
                document.getElementById('alpha').addEventListener('input', function() {{
                    let value = parseFloat(this.value);
                    document.getElementById('alpha-value').textContent = value.toFixed(2);
                    updateSettings({{'alpha': value}});
                }});
                
                document.getElementById('blur').addEventListener('input', function() {{
                    let value = parseInt(this.value);
                    document.getElementById('blur-value').textContent = value;
                    updateSettings({{'blur_size': value}});
                }});
                
                // 复选框事件
                document.getElementById('show-hotspots').addEventListener('change', function() {{
                    updateSettings({{'show_hotspots': this.checked}});
                }});
                
                document.getElementById('enhance-contrast').addEventListener('change', function() {{
                    updateSettings({{'enhance_contrast': this.checked}});
                }});
                
                // 颜色映射选择
                document.getElementById('colormap').addEventListener('change', function() {{
                    updateSettings({{'colormap': parseInt(this.value)}});
                }});
            }};
            
            // 更新状态信息
            function updateStatus() {{
                fetch('/perception')
                    .then(response => response.json())
                    .then(data => {{
                        // 更新UI状态
                        perceptionEnabled = data.config.enable;
                        
                        // 更新按钮状态
                        const toggleBtn = document.getElementById('toggle-perception');
                        toggleBtn.textContent = perceptionEnabled ? '禁用热成像' : '启用热成像';
                        
                        // 更新导航按钮状态
                        const navBtn = document.getElementById('auto-navigation');
                        navBtn.classList.toggle('disabled', !perceptionEnabled);
                        
                        // 更新热成像数据
                        const thermalData = document.getElementById('thermal-data');
                        if (data.hot_spots && data.hot_spots.length > 0) {{
                            thermalData.innerHTML = '检测到热点:<br>' + 
                                data.hot_spots.map(h => `x:${{h[0]}}, y:${{h[1]}}, 温度:${{h[2].toFixed(1)}}`).join('<br>');
                        }} else {{
                            thermalData.innerHTML = '未检测到热点区域';
                        }}
                        
                        // 更新状态文本
                        const statusEl = document.getElementById('status');
                        const lastUpdate = data.last_update ? new Date(data.last_update * 1000).toLocaleTimeString() : '从未';
                        statusEl.innerHTML = `状态: 热成像${{perceptionEnabled ? '已启用' : '已禁用'}}, 最后更新: ${{lastUpdate}}`;
                    }})
                    .catch(error => {{
                        console.error('获取状态失败:', error);
                        document.getElementById('status').textContent = '状态: 获取失败';
                    }});
            }}
            
            // 切换感知功能
            function togglePerception() {{
                fetch('/perception', {{
                    method: 'POST',
                    headers: {{
                        'Content-Type': 'application/json',
                    }},
                    body: JSON.stringify({{
                        enable: !perceptionEnabled
                    }})
                }})
                .then(response => response.json())
                .then(data => {{
                    if (data.success !== false) {{
                        perceptionEnabled = data.enable;
                        updateStatus();
                    }}
                }})
                .catch(error => console.error('操作失败:', error));
            }}
            
            // 更新热成像设置
            function updateSettings(settings) {{
                // 更新本地设置
                Object.assign(currentSettings, settings);
                
                fetch('/perception', {{
                    method: 'POST',
                    headers: {{
                        'Content-Type': 'application/json',
                    }},
                    body: JSON.stringify({{
                        settings: currentSettings
                    }})
                }})
                .then(response => response.json())
                .then(data => {{
                    if (data.success !== false) {{
                        console.log('设置已更新');
                    }}
                }})
                .catch(error => console.error('更新设置失败:', error));
            }}
            
            // 切换自主导航 (需要后端支持)
            function toggleNavigation() {{
                // 仅当感知功能启用时才可用
                if (!perceptionEnabled) {{
                    alert('请先启用热成像功能');
                    return;
                }}
                
                // 这里添加与ESP32通信的代码
                alert('自主导航功能尚未实现');
            }}
        </script>
    </body>
    </html>
    """

def health_check():
    """健康检查函数，监控和维护系统状态"""
    global picam2, running, last_frame_time
    last_check = time.time()
    
    while running:
        current_time = time.time()
        
        # 每隔设定时间进行一次健康检查
        if current_time - last_check >= health_check_interval:
            logger.info("执行健康检查...")
            
            # 检查最后一帧的时间
            if current_time - last_frame_time > frame_timeout:
                logger.warning(f"帧超时 ({current_time - last_frame_time:.1f}秒没有新帧)，重置摄像头")
                reset_camera()
            
            # 输出当前状态
            with clients_lock, stats_lock:
                logger.info(f"服务状态 - 活跃客户端: {active_clients}/{max_clients}, FPS: {fps_stats['current']:.2f}")
            
            last_check = current_time
        
        # 短暂休眠以减少CPU使用
        time.sleep(1)

# 在处理大量连接时动态调整性能
def adjust_performance():
    """监控并自动调整性能参数，保持稳定的高帧率"""
    global reduce_processing, fps_stats, frame_stats
    
    while running:
        try:
            with stats_lock:
                current_fps = fps_stats["current"]
                
            # 判断性能
            if current_fps < 5 and not reduce_processing:
                # 帧率太低，减少处理复杂度
                reduce_processing = True
                logger.info("性能优化: 帧率过低，降低处理复杂度")
                
                # 记录丢帧
                with stats_lock:
                    frame_stats["dropped_frames"] += 1
                
            elif current_fps > 15 and reduce_processing:
                # 帧率恢复，可以增加处理复杂度
                reduce_processing = False
                logger.info("性能优化: 帧率良好，恢复完整处理")
            
            # 每5秒检查一次
            time.sleep(5)
                
        except Exception as e:
            logger.error(f"性能调整错误: {e}")
            time.sleep(5)

# 增加主线程服务启动
if __name__ == "__main__":
    try:
        # 注册信号处理
        signal.signal(signal.SIGTERM, signal_handler)
        signal.signal(signal.SIGINT, signal_handler)
        
        logger.info("====================================")
        logger.info("🤖 启动摄像头流服务")
        logger.info("📷 初始化摄像头")
        # 初始化摄像头
        if init_camera():
            # 启动性能调整线程
            performance_thread = threading.Thread(target=adjust_performance)
            performance_thread.daemon = True
            performance_thread.start()
            
            # 启动健康检查线程
            health_thread = threading.Thread(target=health_check)
            health_thread.daemon = True
            health_thread.start()
            
            # 启动图像捕获线程
            capture_thread = threading.Thread(target=capture_continuous)
            capture_thread.daemon = True
            capture_thread.start()
            
            logger.info("🌐 启动Web服务")
            logger.info(f"📊 首页: http://{get_ip_address()}:8000/")
            logger.info(f"👁 视频流: http://{get_ip_address()}:8000/video_feed")
            logger.info(f"🔍 调试页面: http://{get_ip_address()}:8000/debug")
            logger.info(f"🧠 环境感知: http://{get_ip_address()}:8000/perception.html")
            
            # 启动Flask
            app.run(host='0.0.0.0', port=8000, threaded=True)
        else:
            logger.error("无法初始化摄像头，退出服务")
            sys.exit(1)
    except Exception as e:
        logger.error(f"服务启动错误: {e}")
        sys.exit(1)
