from flask import Flask, Response
from picamera2 import Picamera2
import cv2
import time
import threading
import numpy as np
import os
import signal
import sys

app = Flask(__name__)
picam2 = None
camera_lock = threading.Lock()
running = True

def signal_handler(sig, frame):
    global running
    print("正在关闭摄像头服务...")
    running = False
    if picam2 is not None:
        picam2.stop()
    sys.exit(0)

# 注册信号处理器
signal.signal(signal.SIGINT, signal_handler)
signal.signal(signal.SIGTERM, signal_handler)

def init_camera():
    global picam2
    if picam2 is None:
        picam2 = Picamera2()
        
        # 优化视频配置
        config = picam2.create_video_configuration(
            main={
                "size": (640, 480),
                "format": "RGB888"
            },
            controls={
                "FrameDurationLimits": (33333, 33333),  # 30fps
                "AwbEnable": True,
                "AwbMode": 1,  # 日光模式
                "ColourGains": (1.4, 1.2),  # 红绿增益
                "Brightness": 0.15,  # 稍微增加亮度
                "Contrast": 1.1,     # 稍微增加对比度
                "Saturation": 1.2,   # 增加饱和度
                "ExposureValue": 0.0,  # 调整曝光
                "Sharpness": 1.2,    # 增加锐度
                "NoiseReductionMode": 1  # 降噪模式
            }
        )
        
        picam2.configure(config)
        picam2.start()
        print("摄像头初始化完成")
        time.sleep(2)  # 等待摄像头稳定

def adjust_colors(frame):
    # 转换为浮点数类型进行处理
    frame = frame.astype(np.float32)
    
    # 分离通道
    b, g, r = cv2.split(frame)
    
    # 调整颜色通道强度
    r = r * 1.15  # 红色
    g = g * 1.05  # 绿色 - 稍微增加
    b = b * 0.85  # 蓝色 - 稍微增加
    
    # 检测高亮区域
    brightness = (r + g + b) / 3
    white_mask = (brightness > 210).astype(np.float32)
    
    # 在高亮区域调整颜色
    r = r - white_mask * 15
    g = g - white_mask * 10
    b = b + white_mask * 5
    
    # 整体提亮
    r = r + 10
    g = g + 10
    b = b + 10
    
    # 确保值在有效范围内
    r = np.clip(r, 0, 255)
    g = np.clip(g, 0, 255)
    b = np.clip(b, 0, 255)
    
    # 合并通道并转回uint8类型
    frame_adjusted = cv2.merge([b, g, r])
    frame_adjusted = frame_adjusted.astype(np.uint8)
    
    # 应用轻微锐化
    kernel = np.array([[-1,-1,-1], [-1,9,-1], [-1,-1,-1]])
    frame_adjusted = cv2.filter2D(frame_adjusted, -1, kernel)
    
    return frame_adjusted

def generate_frames():
    global picam2, running
    last_frame_time = time.time()
    frame_count = 0
    start_time = time.time()
    
    while running:
        current_time = time.time()
        frame_interval = 1/30.0  # 30fps
        
        # 限制帧率
        if current_time - last_frame_time < frame_interval:
            time.sleep(0.001)  # 短暂休眠以减少CPU使用
            continue
            
        with camera_lock:
            if picam2 is None:
                init_camera()
                if picam2 is None:
                    time.sleep(0.5)
                    continue
                    
            try:
                frame = picam2.capture_array()
                frame = adjust_colors(frame)
                
                # 添加时间戳
                timestamp = time.strftime("%Y-%m-%d %H:%M:%S", time.localtime())
                cv2.putText(frame, timestamp, (10, 30), cv2.FONT_HERSHEY_SIMPLEX, 0.6, (255, 255, 255), 2)
                
                # 压缩设置 - 提高质量
                encode_params = [cv2.IMWRITE_JPEG_QUALITY, 90]
                ret, buffer = cv2.imencode('.jpg', frame, encode_params)
                
                if not ret:
                    print("编码帧失败")
                    time.sleep(0.1)
                    continue
                    
                frame_bytes = buffer.tobytes()
                
                # 计算FPS
                frame_count += 1
                if frame_count % 30 == 0:
                    end_time = time.time()
                    fps = frame_count / (end_time - start_time)
                    print(f"当前FPS: {fps:.2f}")
                    frame_count = 0
                    start_time = time.time()
                
                yield (b'--frame\r\n'
                       b'Content-Type: image/jpeg\r\n\r\n' + frame_bytes + b'\r\n')
                
                last_frame_time = current_time
                
            except Exception as e:
                print(f"捕获帧时出错: {e}")
                time.sleep(0.5)

@app.route('/')
def index():
    return """
    <!DOCTYPE html>
    <html>
    <head>
        <title>摄像头流</title>
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <style>
            body {
                font-family: Arial, sans-serif;
                margin: 0;
                padding: 20px;
                text-align: center;
                background-color: #f0f0f0;
            }
            h1 {
                color: #333;
            }
            .container {
                max-width: 800px;
                margin: 0 auto;
                background: white;
                padding: 20px;
                border-radius: 8px;
                box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            }
            img {
                max-width: 100%;
                border-radius: 4px;
            }
        </style>
    </head>
    <body>
        <div class="container">
            <h1>摄像头流</h1>
            <img src="/video_feed" alt="摄像头流">
            <p>树莓派摄像头服务正在运行</p>
        </div>
    </body>
    </html>
    """

@app.route('/video_feed')
def video_feed():
    return Response(generate_frames(),
                    mimetype='multipart/x-mixed-replace; boundary=frame')

def check_camera_connection():
    while running:
        with camera_lock:
            if picam2 is None:
                try:
                    init_camera()
                except Exception as e:
                    print(f"初始化摄像头失败: {e}")
        time.sleep(10)  # 每10秒检查一次

if __name__ == '__main__':
    try:
        # 在一个新线程中初始化摄像头
        init_thread = threading.Thread(target=init_camera)
        init_thread.daemon = True
        init_thread.start()
        
        # 启动摄像头连接检查线程
        check_thread = threading.Thread(target=check_camera_connection)
        check_thread.daemon = True
        check_thread.start()
        
        # 启动Flask应用
        print("摄像头服务器开始运行在 http://0.0.0.0:8000")
        app.run(host='0.0.0.0', port=8000, threaded=True)
        
    except KeyboardInterrupt:
        print("接收到终止信号，关闭服务...")
    finally:
        running = False
        if picam2 is not None:
            picam2.stop()
        print("摄像头服务已关闭")
